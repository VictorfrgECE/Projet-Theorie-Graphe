import java.io.*;
import java.util.*;

class Arc {
    int target;
    int weight;
    public Arc(int target, int weight) {
        this.target = target;
        this.weight = weight;
    }
}

public class CollecteMaisonOriente {

    private Map<Integer, List<Arc>> adj = new HashMap<>();
    private int[][] distMatrix; // Matrice des distances pour le plus court chemin
    private int[][] nextNode;   // Pour reconstruire le chemin étape par étape
    private int numNodes = 0;

    public static void main(String[] args) {
        new CollecteMaisonOriente().run();
    }

    public void run() {
        // 1. Chargement du graphe orienté
        // ATTENTION : Vérifie bien que ce chemin est correct sur ta machine
        String cheminFichier = "/Users/corentinlepeltier/IdeaProjects/eval4/src/graphe.txt";

        if (!loadGraph(cheminFichier)) {
            System.out.println("Astuce : Vérifiez que le fichier existe bien à l'endroit indiqué.");
            return;
        }

        // 2. Calcul des trajets possibles (Floyd-Warshall)
        computeFloydWarshall();

        Scanner scanner = new Scanner(System.in);
        System.out.println("--- COLLECTE CHEZ UN PARTICULIER (HO2 - Orienté) ---");
        System.out.println("Le camion part du dépôt (0), ramasse la poubelle sur l'arc donné, et revient.");

        int u = -1, v = -1;
        int poidsArc = -1;

        // --- 3. BOUCLE DE VALIDATION ---
        while (true) {
            try {
                System.out.println("\nEntrez les deux sommets délimitant la rue (dans le sens de circulation) :");
                System.out.print("  1. Sommet de DÉBUT de la rue (ex: 7) : ");
                u = scanner.nextInt();
                System.out.print("  2. Sommet de FIN de la rue   (ex: 4) : ");
                v = scanner.nextInt();

                // Vérifie si l'arc u -> v existe spécifiquement
                poidsArc = getArcWeight(u, v);

                if (poidsArc != -1) {
                    System.out.println("  > OK ! La poubelle se trouve sur la section " + u + " -> " + v + " (" + poidsArc + "m).");
                    break; // Sortie de boucle car la saisie est valide
                } else {
                    System.err.println("  > ERREUR : Il n'y a pas de route directe allant de " + u + " vers " + v + ".");
                    System.err.println("    (Si c'est un sens unique, essayez l'autre sens ou vérifiez le fichier).");
                }
            } catch (InputMismatchException e) {
                System.out.println("  > Erreur : Entrez des nombres entiers !");
                scanner.next(); // Vider le buffer
            }
        }

        // --- 4. CALCUL DE L'ITINÉRAIRE ---
        // Le plan est : Dépôt (0) -> Aller vers u -> Traverser u->v (Collecte) -> Retour de v vers 0

        // Vérification de sécurité (si le graphe est mal connecté)
        if (distMatrix[0][u] >= 999999 || distMatrix[v][0] >= 999999) {
            System.out.println("Impossible : Le camion ne peut pas atteindre le début de la rue ou ne peut pas revenir du dépôt.");
            return;
        }

        System.out.println("\n--- DÉTAIL DE LA TOURNÉE ---");

        // 1. ALLER
        System.out.print("1. TRAJET À VIDE (Dépôt -> " + u + ") : ");
        printPath(0, u);
        System.out.println();

        // 2. COLLECTE
        System.out.println("2. COLLECTE (Ramassage)        : " + u + " -> " + v + " (" + poidsArc + "m)");

        // 3. RETOUR
        System.out.print("3. RETOUR DÉPÔT (" + v + " -> Dépôt) : ");
        printPath(v, 0);
        System.out.println();

        // Calcul Total
        int distanceAller = distMatrix[0][u];
        int distanceRetour = distMatrix[v][0];
        int total = distanceAller + poidsArc + distanceRetour;

        System.out.println("\n-------------------------------------------");
        System.out.println("DISTANCE TOTALE PARCOURUE : " + total + " mètres.");
        System.out.println("-------------------------------------------");
    }

    // --- MÉTHODES UTILES ---

    // Cherche le poids de l'arc direct u -> v dans la liste d'adjacence
    int getArcWeight(int u, int v) {
        if (!adj.containsKey(u)) return -1;
        for (Arc a : adj.get(u)) {
            if (a.target == v) return a.weight;
        }
        return -1;
    }

    // Affiche le chemin étape par étape en utilisant la matrice nextNode
    void printPath(int start, int end) {
        if (start == end) {
            System.out.print(start + " (Déjà sur place)");
            return;
        }
        int curr = start;
        System.out.print(curr);
        while (curr != end) {
            curr = nextNode[curr][end];
            System.out.print(" -> " + curr);
        }
        System.out.print(" (Dist: " + distMatrix[start][end] + "m)");
    }

    // Algorithme de Floyd-Warshall pour tous les plus courts chemins
    void computeFloydWarshall() {
        distMatrix = new int[numNodes][numNodes];
        nextNode = new int[numNodes][numNodes];

        // Initialisation à l'infini
        for (int i = 0; i < numNodes; i++) {
            Arrays.fill(distMatrix[i], 999999);
            distMatrix[i][i] = 0;
        }

        // Remplissage initial avec les arcs directs connus
        for (int u : adj.keySet()) {
            for (Arc a : adj.get(u)) {
                // On garde le poids minimal si jamais il y a plusieurs arcs (rare ici)
                if (a.weight < distMatrix[u][a.target]) {
                    distMatrix[u][a.target] = a.weight;
                    nextNode[u][a.target] = a.target;
                }
            }
        }

        // Triple boucle de Floyd-Warshall
        for (int k = 0; k < numNodes; k++) {
            for (int i = 0; i < numNodes; i++) {
                for (int j = 0; j < numNodes; j++) {
                    if (distMatrix[i][k] + distMatrix[k][j] < distMatrix[i][j]) {
                        distMatrix[i][j] = distMatrix[i][k] + distMatrix[k][j];
                        nextNode[i][j] = nextNode[i][k];
                    }
                }
            }
        }
    }

    boolean loadGraph(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            int maxId = 0;
            while ((line = br.readLine()) != null) {
                String[] p = line.trim().split("\\s+");
                if (p.length == 4) {
                    int u = Integer.parseInt(p[0]);
                    int v = Integer.parseInt(p[1]);
                    int w = Integer.parseInt(p[2]);
                    int type = Integer.parseInt(p[3]);

                    // Création de l'arc u -> v (TOUJOURS créé, quel que soit le type)
                    adj.computeIfAbsent(u, k -> new ArrayList<>()).add(new Arc(v, w));
                    maxId = Math.max(maxId, Math.max(u, v));

                    // Si Type 2 (Orange/Double sens), on crée AUSSI l'arc inverse v -> u
                    if (type == 2) {
                        adj.computeIfAbsent(v, k -> new ArrayList<>()).add(new Arc(u, w));
                    }
                }
            }
            numNodes = maxId + 1;
            return true;
        } catch (Exception e) {
            System.err.println("Erreur de lecture du fichier : " + e);
            return false;
        }
    }
}
