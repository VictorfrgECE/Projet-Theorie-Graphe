import java.io.*;
import java.util.*;

class Route {
    int u, v, weight;
    int type;
    String id;

    public Route(int u, int v, int weight, int type) {
        this.u = u;
        this.v = v;
        this.weight = weight;
        this.type = type;
        this.id = (u < v) ? u + "-" + v : v + "-" + u;
    }
}

public class CollecteHO3FinaleImpossible {

    List<Route> allEdges = new ArrayList<>();
    List<Route> todoList = new ArrayList<>();
    List<Integer> finalPathSequence = new ArrayList<>();

    int[][] distMatrix;
    int[][] nextNode;
    int numNodes = 0;
    final int INF = 999999;

    public static void main(String[] args) {
        new CollecteHO3FinaleImpossible().run();
    }

    public void run() {
        String cheminFichier = "/Users/corentinlepeltier/IdeaProjects/eval4/src/graphe.txt";
        if (!loadGraph(cheminFichier)) return;

        computeFloydWarshall();

        Scanner scanner = new Scanner(System.in);
        System.out.println("--- COLLECTE HO3 (Détection IMPOSSIBLE) ---");

        Set<String> asked = new HashSet<>();
        for (Route r : allEdges) {
            if (r.type == 3) {
                if (asked.contains(r.id)) continue;
                asked.add(r.id);
                System.out.print(" - Rue ROUGE " + r.u + " <-> " + r.v + " (" + r.weight + "m) : ");
            } else {
                System.out.print(" - Voie " + r.u + " -> " + r.v + " (" + r.weight + "m) : ");
            }
            if (scanner.next().equalsIgnoreCase("o")) todoList.add(r);
        }

        if (todoList.isEmpty()) return;

        System.out.println("\n--- DÉMARRAGE TOURNÉE ---");
        int currentPos = 0;
        int totalDist = 0;
        finalPathSequence.add(0);

        while (!todoList.isEmpty()) {
            Route bestRoute = null;
            int bestDist = INF;
            int bestStart = -1;
            int bestEnd = -1;

            boolean forceReturn = true;
            for (Route r : todoList) {
                if (r.type == 3) { if (r.u != 0 && r.v != 0) forceReturn = false; }
                else { if (r.v != 0) forceReturn = false; }
                if (!forceReturn) break;
            }

            for (Route r : todoList) {
                List<Integer> starts = new ArrayList<>();
                List<Integer> ends = new ArrayList<>();

                if (r.type == 3) {
                    starts.add(r.u); ends.add(r.v);
                    starts.add(r.v); ends.add(r.u);
                } else {
                    starts.add(r.u); ends.add(r.v);
                }

                for (int i = 0; i < starts.size(); i++) {
                    int s = starts.get(i);
                    int e = ends.get(i);

                    if (!forceReturn && e == 0) continue;

                    int d = distMatrix[currentPos][s];
                    if (d >= INF) continue;

                    if (d < bestDist) {
                        bestDist = d;
                        bestRoute = r;
                        bestStart = s;
                        bestEnd = e;
                    }
                }
            }

            if (bestRoute == null) {
                // --- MODIFICATION ICI ---
                // Si on est bloqué, on arrête tout et on signale l'échec.
                System.out.println("\n[ERREUR CRITIQUE] Impossible de continuer la tournée.");
                System.out.println("Raison : Graphe déconnecté ou sens uniques bloquants (Puits).");
                System.out.println("------------------------------------------------");
                System.out.println("RÉSULTAT : IMPOSSIBLE");
                return; // Fin immédiate du programme
            }

            if (bestDist > 0) {
                System.out.println("   [Trajet] " + currentPos + " -> " + bestStart + " (" + bestDist + "m)");
                addPathToSequence(currentPos, bestStart);
                totalDist += bestDist;
            }

            String info = (bestRoute.type == 3) ? " [Sens Optimisé]" : "";
            System.out.println("   [Collecte] " + bestStart + " -> " + bestEnd + " (" + bestRoute.weight + "m)" + info);

            finalPathSequence.add(bestEnd);
            totalDist += bestRoute.weight;
            currentPos = bestEnd;
            removeTask(bestRoute.id);
        }

        // Retour Final
        if (currentPos != 0) {
            int dRetour = distMatrix[currentPos][0];
            // --- MODIFICATION ICI AUSSI ---
            if (dRetour >= INF) {
                System.out.println("\n[ERREUR CRITIQUE] Impossible de rentrer au dépôt !");
                System.out.println("Le camion est coincé au sommet " + currentPos + ".");
                System.out.println("------------------------------------------------");
                System.out.println("RÉSULTAT : IMPOSSIBLE");
                return;
            }

            System.out.println("   [Fin] Retour dépôt (" + dRetour + "m)");
            addPathToSequence(currentPos, 0);
            totalDist += dRetour;
        }

        System.out.println("\n===========================================");
        System.out.println("DISTANCE TOTALE : " + totalDist + " mètres");
        System.out.print("CHEMIN FINAL : ");
        for (int i = 0; i < finalPathSequence.size(); i++) {
            System.out.print(finalPathSequence.get(i));
            if (i < finalPathSequence.size() - 1) System.out.print(" -> ");
        }
        System.out.println("\n===========================================");
    }

    void removeTask(String id) {
        todoList.removeIf(r -> r.id.equals(id));
    }

    void computeFloydWarshall() {
        distMatrix = new int[numNodes][numNodes];
        nextNode = new int[numNodes][numNodes];

        for (int i = 0; i < numNodes; i++) {
            Arrays.fill(distMatrix[i], INF);
            distMatrix[i][i] = 0;
        }

        for (Route r : allEdges) {
            if (r.weight < distMatrix[r.u][r.v]) {
                distMatrix[r.u][r.v] = r.weight;
                nextNode[r.u][r.v] = r.v;
            }
        }

        for (int k = 0; k < numNodes; k++) {
            for (int i = 0; i < numNodes; i++) {
                for (int j = 0; j < numNodes; j++) {
                    if (distMatrix[i][k] + distMatrix[k][j] < distMatrix[i][j]) {
                        distMatrix[i][j] = distMatrix[i][k] + distMatrix[k][j];
                        nextNode[i][j] = nextNode[i][k];
                    }
                }
            }
        }
    }

    void addPathToSequence(int start, int end) {
        if (start == end) return;
        int curr = start;
        while (curr != end) {
            curr = nextNode[curr][end];
            finalPathSequence.add(curr);
        }
    }

    boolean loadGraph(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            int maxId = 0;
            while ((line = br.readLine()) != null) {
                String[] p = line.trim().split("\\s+");
                if (p.length >= 4) {
                    int u = Integer.parseInt(p[0]);
                    int v = Integer.parseInt(p[1]);
                    int w = Integer.parseInt(p[2]);
                    int type = Integer.parseInt(p[3]);
                    allEdges.add(new Route(u, v, w, type));
                    if (type == 2 || type == 3) {
                        allEdges.add(new Route(v, u, w, type));
                    }
                    maxId = Math.max(maxId, Math.max(u, v));
                }
            }
            numNodes = maxId + 1;
            return true;
        } catch (Exception e) { return false; }
    }
}
