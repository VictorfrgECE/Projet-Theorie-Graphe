import java.util.*;

class AlgorithmesTSP {
  public static List<Integer> approcheMST(Graphe g, int idDepot, double[][] distMatrice) {
        // 1. Identifier les sommets d'intérêt (Dépôt + Points de collecte)
        List<Integer> sommetsInteret = new ArrayList<>();
        sommetsInteret.add(idDepot);
        for (Sommet s : g.getTousLesSommets()) {
            if (!s.depot && s.contenance > 0) sommetsInteret.add(s.id);
        }

        // Map pour convertir ID réel <-> Index local pour l'algo de Prim
        Map<Integer, Integer> realToLocal = new HashMap<>();
        Map<Integer, Integer> localToReal = new HashMap<>();
        for (int i = 0; i < sommetsInteret.size(); i++) {
            realToLocal.put(sommetsInteret.get(i), i);
            localToReal.put(i, sommetsInteret.get(i));
        }

        int n = sommetsInteret.size(); // Nombre de noeuds dans le graphe complet

        // 2. Prim's Algorithm pour construire l'MST
        // Note : Sur un graphe orienté, dist[u][v] != dist[v][u].
        // Pour l'MST "non orienté" (Hypothèse 1), on considère le graphe comme symétrique.
        // On peut prendre min(d[u][v], d[v][u]) ou juste d[u][v] si on suppose HO1.
        double[] keys = new double[n];
        int[] parent = new int[n];
        boolean[] inMST = new boolean[n];
        Arrays.fill(keys, Double.POSITIVE_INFINITY);
        Arrays.fill(parent, -1);

        // On commence par le dépôt (index local 0)
        keys[0] = 0;

        for (int count = 0; count < n - 1; count++) {
            // Choisir le sommet u avec la plus petite clé
            double min = Double.POSITIVE_INFINITY;
            int u = -1;
            for (int i = 0; i < n; i++) {
                if (!inMST[i] && keys[i] < min) {
                    min = keys[i];
                    u = i;
                }
            }

            if (u == -1) break; // Graphe non connexe
            inMST[u] = true;

            // Mettre à jour les voisins
            int uReal = localToReal.get(u);
            for (int v = 0; v < n; v++) {
                if (!inMST[v]) {
                    int vReal = localToReal.get(v);
                    // Distance dans le graphe complet = plus court chemin
                    // Pour MST, on symétrise souvent si on veut un arbre "structurel"
                    // Ici on prend simplement la distance directe u->v
                    double weight = distMatrice[uReal][vReal];

                    if (weight < keys[v]) {
                        parent[v] = u;
                        keys[v] = weight;
                    }
                }
            }
        }

        // 3. Construire l'arbre (liste d'adjacence) pour le parcours
        List<List<Integer>> arbreAdj = new ArrayList<>();
        for (int i = 0; i < n; i++) arbreAdj.add(new ArrayList<>());

        for (int i = 1; i < n; i++) {
            if (parent[i] != -1) {
                arbreAdj.get(parent[i]).add(i);
                // On traite l'arbre comme non-orienté pour le parcours
                arbreAdj.get(i).add(parent[i]);
            }
        }

        // 4. Parcours Préfixe (DFS) partant du dépôt
        List<Integer> ordreLocal = new ArrayList<>();
        boolean[] visite = new boolean[n];
        dfsPreordre(0, arbreAdj, visite, ordreLocal);

        // 5. Convertir en IDs réels et enlever le dépôt (pour le découpage)
        List<Integer> resultat = new ArrayList<>();
        for (int idx : ordreLocal) {
            int realId = localToReal.get(idx);
            if (realId != idDepot) {
                resultat.add(realId);
            }
        }
        return resultat;
    }

    private static void dfsPreordre(int u, List<List<Integer>> adj, boolean[] visite, List<Integer> res) {
        visite[u] = true;
        res.add(u);
        for (int v : adj.get(u)) {
            if (!visite[v]) {
                dfsPreordre(v, adj, visite, res);
            }
        }
    }

    // =================================================================
    // OUTILS : Découpage par capacité
    // =================================================================
    public static List<List<Integer>> decouperTournees(List<Integer> ordrePoints, Graphe g, int idDepot, int capaciteMax) {
        List<List<Integer>> tournees = new ArrayList<>();

        List<Integer> tourActuel = new ArrayList<>();
        tourActuel.add(idDepot); // Départ
        int chargeActuelle = 0;

        for (int idPoint : ordrePoints) {
            Sommet s = g.getSommet(idPoint);
            if (s.contenance + chargeActuelle > capaciteMax) {
                // Le camion est plein : retour au dépôt
                tourActuel.add(idDepot);
                tournees.add(tourActuel);

                // Nouvelle tournée
                tourActuel = new ArrayList<>();
                tourActuel.add(idDepot);
                chargeActuelle = 0;
            }

            // Ajouter le point
            tourActuel.add(idPoint);
            chargeActuelle += s.contenance;
        }

        // Finir la dernière tournée
        tourActuel.add(idDepot);
        tournees.add(tourActuel);

        return tournees;
    }
}
public class Arete {
    int from;
    int to;
    double poids;

    public Arete(int from, int to, double poids) {
        this.from = from;
        this.to = to;
        this.poids = poids;
    }
}
import java.util.*;

public class Graphe {
    private List<Sommet> sommets = new ArrayList<>();
    private Map<Integer, List<Arete>> adjacence = new HashMap<>();

    public void ajouterSommet(Sommet s) {
        while (sommets.size() <= s.id) {
            sommets.add(null);
        }
        sommets.set(s.id, s);
        adjacence.putIfAbsent(s.id, new ArrayList<>());
    }

    public void ajouterArete(int u, int v, double poids) {
        adjacence.putIfAbsent(u, new ArrayList<>());
        adjacence.putIfAbsent(v, new ArrayList<>());
        adjacence.get(u).add(new Arete(u, v, poids));
    }

    public void ajouterAreteNonOriente(int u, int v, double poids) {
        ajouterArete(u, v, poids);
        ajouterArete(v, u, poids);
    }

    public Sommet getSommet(int id) {
        if (id < 0 || id >= sommets.size()) return null;
        return sommets.get(id);
    }

    public int getNombreSommets() {
        return sommets.size();
    }

    public List<Arete> getVoisins(int id) {
        return adjacence.getOrDefault(id, Collections.emptyList());
    }

    public List<Sommet> getTousLesSommets() {
        List<Sommet> res = new ArrayList<>();
        for (Sommet s : sommets) {
            if (s != null) res.add(s);
        }
        return res;
    }

    // --- DIJKSTRA STANDARD ---
    // Retourne {distances[], parents[]}
    public DijkstraResult dijkstra(int sourceId) {
        int n = getNombreSommets();
        double[] dist = new double[n];
        int[] parent = new int[n];
        boolean[] visite = new boolean[n];

        Arrays.fill(dist, Double.POSITIVE_INFINITY);
        Arrays.fill(parent, -1);
        dist[sourceId] = 0.0;

        // PriorityQueue stocke {distance, sommetId}
        PriorityQueue<double[]> pq = new PriorityQueue<>(Comparator.comparingDouble(a -> a[0]));
        pq.add(new double[]{0.0, sourceId});

        while (!pq.isEmpty()) {
            double[] courant = pq.poll();
            double d = courant[0];
            int u = (int) courant[1];

            if (visite[u]) continue;
            visite[u] = true;

            for (Arete e : getVoisins(u)) {
                int v = e.to;
                if (dist[u] + e.poids < dist[v]) {
                    dist[v] = dist[u] + e.poids;
                    parent[v] = u;
                    pq.add(new double[]{dist[v], v});
                }
            }
        }
        return new DijkstraResult(dist, parent);
    }

    // Calcule la matrice de distances complètes (tous vers tous)
    public double[][] calculerMatriceDistances() {
        int n = getNombreSommets();
        double[][] mat = new double[n][n];
        for (int i = 0; i < n; i++) {
            if (getSommet(i) == null) continue;
            DijkstraResult res = dijkstra(i);
            mat[i] = res.dist;
        }
        return mat;
    }

    // Reconstruit le chemin physique (liste de noeuds) de source à cible
    public List<Integer> getPlusCourtCheminPhysique(int source, int cible) {
        DijkstraResult res = dijkstra(source);
        List<Integer> chemin = new ArrayList<>();
        if (res.dist[cible] == Double.POSITIVE_INFINITY) return chemin; // Pas de chemin

        int curr = cible;
        while (curr != -1) {
            chemin.add(curr);
            if (curr == source) break;
            curr = res.parent[curr];
        }
        Collections.reverse(chemin);
        return chemin;
    }

    public static class DijkstraResult {
        public double[] dist;
        public int[] parent;

        public DijkstraResult(double[] dist, int[] parent) {
            this.dist = dist;
            this.parent = parent;
        }
    }
}
import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

class LecteurGraphe {

    public static Graphe chargerDepuisFichier(String nomFichier) throws FileNotFoundException {
        Graphe g = new Graphe();
        // Essayer de lire directement le fichier (chemin relatif)
        File f = new File(nomFichier);
        if (!f.exists()) {
            // Fallback: essayer src/ si exécuté depuis la racine dans un IDE
            f = new File("src/" + nomFichier);
        }

        Scanner sc = new Scanner(f);

        boolean sectionSommets = false;

        while (sc.hasNextLine()) {
            String ligne = sc.nextLine().trim();
            if (ligne.isEmpty() || ligne.startsWith("#") || ligne.startsWith("[")) continue;

            String[] tokens = ligne.split("\\s+");
            String key = tokens[0].toUpperCase();

            if (key.equals("SOMMETS")) {
                int n = Integer.parseInt(tokens[1]);
                for(int i=0; i<n; i++) {
                    // Ignorer les lignes vides ou commentaires à l'intérieur
                    while(sc.hasNextLine()) {
                        String l = sc.nextLine().trim();
                        if(!l.isEmpty() && !l.startsWith("#")) {
                            String[] t = l.split("\\s+");
                            int id = Integer.parseInt(t[0]);
                            String nom = t[1];
                            String type = t[2];
                            int cont = Integer.parseInt(t[3]);
                            g.ajouterSommet(new Sommet(id, nom, type.equalsIgnoreCase("DEPOT"), cont));
                            break;
                        }
                    }
                }
                sectionSommets = true;
            }
            else if (key.equals("ARETES")) {
                if(!sectionSommets) throw new IllegalStateException("Aretes avant Sommets!");
                int m = Integer.parseInt(tokens[1]);
                for(int i=0; i<m; i++) {
                    while(sc.hasNextLine()) {
                        String l = sc.nextLine().trim();
                        if(!l.isEmpty() && !l.startsWith("#")) {
                            String[] t = l.split("\\s+");
                            int u = Integer.parseInt(t[0]);
                            int v = Integer.parseInt(t[1]);
                            double dist = Double.parseDouble(t[2]);

                            // Par défaut Non Orienté (U), sauf si précisé O
                            boolean estOriente = false;
                            if (t.length > 3 && (t[3].equalsIgnoreCase("O") || t[3].startsWith("O"))) {
                                estOriente = true;
                            }

                            if (estOriente) {
                                g.ajouterArete(u, v, dist);
                            } else {
                                g.ajouterAreteNonOriente(u, v, dist);
                            }
                            break;
                        }
                    }
                }
            }
        }
        sc.close();
        return g;
    }
}
import java.util.*;

public class OptimisationRamassageDechets {

    public static void main(String[] args) {
        Scanner console = new Scanner(System.in);
        System.out.println("=== OPTIMISATION RAMASSAGE ===");

        // --- BOUCLE PRINCIPALE (Chargement de graphe) ---
        while (true) {
            System.out.println("\n------------------------------------------------");
            System.out.println("NOUVELLE SESSION DE CHARGEMENT");
            System.out.print("Nom du fichier (ex: graphe_oriente.txt) ou '0' pour quitter : ");
            String nomFichier = console.nextLine();

            if (nomFichier.equals("0")) {
                System.out.println("Fin du programme.");
                break;
            }

            Graphe g;
            try {
                g = LecteurGraphe.chargerDepuisFichier(nomFichier);
            } catch (Exception e) {
                System.out.println("ERREUR : Impossible de charger le fichier (" + e.getMessage() + ")");
                continue;
            }

            System.out.println(">> Graphe chargé : " + g.getNombreSommets() + " sommets.");

            // 1. Trouver ou demander le dépôt
            int idDepot = -1;
            for(Sommet s : g.getTousLesSommets()) {
                if(s.depot) {
                    idDepot = s.id;
                    break;
                }
            }
            if(idDepot == -1) {
                System.out.print("Entrez l'ID du dépôt : ");
                try {
                    idDepot = Integer.parseInt(console.nextLine());
                } catch (NumberFormatException e) {
                    continue;
                }
            } else {
                System.out.println(">> Dépôt : " + g.getSommet(idDepot).nom + " (ID " + idDepot + ")");
            }

            // 2. Demander la capacité
            int capaciteSaisie = 0;
            while (capaciteSaisie <= 0) {
                System.out.print("Capacité du camion : ");
                try {
                    capaciteSaisie = Integer.parseInt(console.nextLine());
                } catch (NumberFormatException e) {
                    System.out.println("Entier requis.");
                }
            }

            System.out.println("Calcul des distances en cours...");
            double[][] matriceDistances = g.calculerMatriceDistances();

            // --- BOUCLE SECONDAIRE (Menu Algo) ---
            boolean changerDeGraphe = false;
            while (!changerDeGraphe) {
                System.out.println("\n===== MENU (Fichier: " + nomFichier + " | Capacité: " + capaciteSaisie + ") =====");
                System.out.println("1. Approche Plus Proche Voisin (PPV)");
                System.out.println("2. Approche MST (Arbre Couvrant)");
                System.out.println("9. Charger un autre graphe");
                System.out.println("0. Quitter");
                System.out.print("Votre choix : ");

                String choix = console.nextLine();

                if (choix.equals("0")) {
                    System.out.println("Au revoir !");
                    System.exit(0);
                }
                else if (choix.equals("9")) {
                    changerDeGraphe = true;
                    continue;
                }

                List<Integer> ordreLogique = null;
                int capacitePourCalcul = capaciteSaisie;

                if (choix.equals("1")) {
                    ordreLogique = AlgorithmesTSP.approchePlusProcheVoisin(g, idDepot);
                    capacitePourCalcul = Integer.MAX_VALUE; // Capacité infinie pour voir tout le trajet
                } else if (choix.equals("2")) {
                    ordreLogique = AlgorithmesTSP.approcheMST(g, idDepot, matriceDistances);
                } else {
                    continue;
                }

                if (ordreLogique == null || ordreLogique.isEmpty()) {
                    System.out.println("Aucun point à collecter.");
                    continue;
                }

                List<List<Integer>> tournes = AlgorithmesTSP.decouperTournees(ordreLogique, g, idDepot, capacitePourCalcul);

                System.out.println("\n--- RÉSULTAT (" + (choix.equals("1") ? "PPV" : "MST") + ") ---");
                System.out.println("(Légende : [Nom] = Arrêt collecte, Nom = Simple passage)");

                double distanceTotaleGlobale = 0.0;

                for (int i = 0; i < tournes.size(); i++) {
                    List<Integer> t = tournes.get(i);
                    double distTournee = 0;
                    List<String> affichageChemin = new ArrayList<>();

                    // Ajout du point de départ
                    affichageChemin.add(formaterSommet(g.getSommet(t.get(0)), true));

                    for (int j = 0; j < t.size() - 1; j++) {
                        int u = t.get(j);
                        int v = t.get(j+1);

                        List<Integer> segment = g.getPlusCourtCheminPhysique(u, v);
                        if (segment.isEmpty()) {
                            System.out.println("    ERREUR: Pas de chemin de " + u + " à " + v);
                            distTournee = Double.POSITIVE_INFINITY;
                            break;
                        }

                        distTournee += matriceDistances[u][v];

                        // Ajout des étapes intermédiaires
                        for(int k=1; k<segment.size(); k++) {
                            int idEtape = segment.get(k);
                            Sommet sEtape = g.getSommet(idEtape);
                            boolean estDestinationLogique = (idEtape == v);
                            affichageChemin.add(formaterSommet(sEtape, estDestinationLogique));
                        }
                    }

                    System.out.println("\n  TOURNEE " + (i+1));
                    System.out.println("  [Logique] : " + t);
                    System.out.println("  [Réel]    : " + String.join(" -> ", affichageChemin));
                    System.out.println("  [Dist.]   : " + String.format("%.2f", distTournee));

                    if (distTournee != Double.POSITIVE_INFINITY)
                        distanceTotaleGlobale += distTournee;
                }

                if (choix.equals("2") && tournes.size() > 1) {
                    System.out.println("\nDISTANCE TOTALE CUMULÉE : " + String.format("%.2f", distanceTotaleGlobale));
                }
            }
        }
    }

    private static String formaterSommet(Sommet s, boolean estArret) {
        if (estArret) {
            if (s.depot) return "[DEPOT " + s.nom + "]";
            return "[" + s.nom + "]";
        } else {
            return s.nom;
        }
    }
}
public class Sommet {
    int id;
    String nom;
    boolean depot;
    int contenance;

    public Sommet(int id, String nom, boolean depot, int contenance) {
        this.id = id;
        this.nom = nom;
        this.depot = depot;
        this.contenance = contenance;
    }

    @Override
    public String toString() {
        return nom + " (Déchets: " + contenance + ")";
    }
}
